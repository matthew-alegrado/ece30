IsContain:
	// input:
	// x0: address of (pointer to) the first symbol of the sub-array
	// x1: address of (pointer to) the last symbol of the sub-array
	// x2: symbol to look for

	// output:
	// x3: 1 if symbol is found, 0 otherwise

    // callee start procedure
	subi sp, sp, #32    // allocate
    stur fp, [sp, #0]   // save old fp
    addi fp, sp, #24    // set new fp
    stur lr, [sp, #8]   // save return address

	// while loop
	// x9/x10: first/second char value
IsContain_while:
	subs xzr, x1, x0        // compare start and end values
	b.gt IsContain_false    // exit while loop if start > end
	ldurb x9, [x0, #0]      // retrieve 1 byte, first char
	ldurb x10, [x1, #0]     // retrieve second char
	subs xzr, x10, x9       // compare the two chars
	b.eq IsContain_matching // if chars match, jump
	addi x0, x0, 2          // increment start by 2
	b IsContain_while       // return to top of while loop


IsContain_matching:
    addi x3, xzr, #1    // return value set to 1
    b IsContain_end

IsContain_false:
    addi x3, x3, #0     // return value set to 1
    b IsContain_end

// handle callee end procedures
IsContain_end:
    ldur lr, [sp, #8]   // load return address
    ldur fp, [sp, #0]   // load old fp
    addi sp, sp, #32    // deallocate stack frame

	br lr